<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="Structured Concurrency in Rust"><meta property="og:description" content="并发，是程序员在日常编程中难以绕开的话题，本文介绍一种并发编程范式-结构化并发(Structured Concurrency)。首先给出它的概念和现状，然后着重介绍 Rust 的一个实现 - task_scope，最后给出一个例子展示如何在实践中使用。"><meta property="og:type" content="article"><meta property="og:url" content="/blog/structured-concurrency-in-rust/"><meta property="article:published_time" content="2020-02-15T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structured Concurrency in Rust"><meta name=twitter:description content="并发，是程序员在日常编程中难以绕开的话题，本文介绍一种并发编程范式-结构化并发(Structured Concurrency)。首先给出它的概念和现状，然后着重介绍 Rust 的一个实现 - task_scope，最后给出一个例子展示如何在实践中使用。"><meta name=generator content="Hugo 0.62.0"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Structured Concurrency in Rust","url":"\/blog\/structured-concurrency-in-rust\/","wordCount":"3445","datePublished":"2020-02-15T00:00:00+00:00","dateModified":"2020-02-15T00:00:00+00:00","author":{"@type":"Person","name":"lerencao"},"keywords":"rust, concurrency, structured, goto, scope, blog","description":"并发，是程序员在日常编程中难以绕开的话题，本文介绍一种并发编程范式-结构化并发(Structured Concurrency)。首先给出它的概念和现状，然后着重介绍 Rust 的一个实现 - task_scope，最后给出一个例子展示如何在实践中使用。"}</script><link rel=canonical href=../../blog/structured-concurrency-in-rust/><title>Structured Concurrency in Rust | Westar</title><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-WQSZ69DVJZ"></script><script>    window.dataLayer = window.dataLayer || [];    function gtag(){dataLayer.push(arguments);}    gtag('js', new Date());    gtag('config', 'G-WQSZ69DVJZ');</script><link rel=stylesheet href=../../css/amazeui.min.css><link rel=stylesheet href=../../css/style.css></head><body><header class="am-topbar am-topbar-fixed-top header-light" style=background:#fff><div class=am-container-big><h1 class=am-topbar-brand><a href=../../ alt="westar logo" class=logo-a><img src=../../images/logo_dark.png alt></a></h1><button class="am-topbar-btn am-topbar-toggle am-btn am-btn-sm am-btn-secondary am-show-sm-only" data-am-collapse="{target: '#collapse-head'}"><span class=am-sr-only>导航切换</span> <span class=am-icon-bars></span></button><div class="am-collapse am-topbar-collapse" id=collapse-head><div class=am-topbar-right><ul class="am-nav am-nav-pills am-topbar-nav"><li><a href=../../blog/>博客</a></li><li class=am-dropdown data-am-dropdown><a class=am-dropdown-toggle data-am-dropdown-toggle href=javascript:void(0);>项目</a><ul class=am-dropdown-content><li><a href=https://starcoin.org><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Starcoin Blockchain</h3><div class=section-faq-desc>新⼀代分层的智能合约和分布式⾦融⽹络</div></div></div></a></li><li><a href=../../projects/sirius/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Sirius Protocol</h3><div class=section-faq-desc>去中心化、安全、多方、及时的二层支付协议</div></div></div></a></li><li><a href=../../projects/stargate/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Stargate Protocol</h3><div class=section-faq-desc>Starcoin 的二层协议实现</div></div></div></a></li><li><a href=../../projects/thor/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Thor Protocol</h3><div class=section-faq-desc>闪电网络上的智能合约和仲裁服务</div></div></div></a></li></ul></li><li><a href=../../about/>关于我们</a></li><li><a href=../../blog/westar_careers/>加入我们</a></li></ul></div></div></div></header><div class=news-container-detail><div class=am-container><div class=blog-main><article data-am-widget=paragraph class="am-paragraph am-paragraph-default" data-am-paragraph="{ tableScrollable: true, pureview: true }"><header><h2 class="news-title about-color blog-post-title" dir=auto>Structured Concurrency in Rust</h2><p class=blog-post-meta><time datetime=2020-02-15T00:00:00Z>Sat Feb 15, 2020</time>
by
lerencao
in
<i class="fa fa-folder" aria-hidden=true></i>&nbsp;<a href=../../categories/blog rel="category tag">blog</a>
<i class="fa fa-tag" aria-hidden=true></i>&nbsp;<a href=../../tags/rust rel=tag>rust</a>, <a href=../../tags/concurrency rel=tag>concurrency</a></p></header><p>并发，是程序员在日常编程中难以绕开的话题，本文介绍一种并发编程范式-结构化并发(Structured Concurrency)。首先给出它的概念和现状，然后着重介绍 Rust 的一个实现 - task_scope，最后给出一个例子展示如何在实践中使用。</p><h2 id=the-pain-of-concurrency-programming>The Pain of concurrency programming</h2><p>熟悉 Go 语言的朋友都知道，可以通过 <code>go myfunc()</code> 轻易的创建一个和当前协程并发执行的 task。但是，当程序变复杂， <em>go statement</em> 变的越来越多时，就会遇到各种 task 生命周期的问题。</p><ul><li>这个 task 什么时候开始，什么时候结束？</li><li>怎么做到当所有 subtask 都结束，main task再结束？</li><li>假如某个 subtask 失败，main task 如何cancel 掉其他subtask？</li><li>如何保证所有 subtask 在某个特定的超时时间内返回，无论它成功还是失败？</li><li>更进一步，如何保证 main task 在规定的时间内返回，无论其成功还是失败，同时 cancel 掉它产生的所有 subtask？</li><li>main task 已经结束了，subtask 还在 running，是不是存在资源泄漏？</li></ul><p>以上只是我根据自己过往的经验，随便列举的几类问题。当然这些问题在 Golang 里面都是可以解的，具体可以参考 Golang Official Blog 里几篇讲 Golang Concurrency Patterns 的文章。它需要程序按照一些特定的行为方式去组织，比如说方法参数带上 <code>Context</code>，通过它去传递 cancellation 信号。</p><blockquote><p><a href=https://blog.golang.org/context>Go Concurrency Patterns: Context</a></p><p><a href=https://blog.golang.org/pipelines>Go Concurrency Patterns: Pipelines and cancellation</a></p><p><a href=https://blog.golang.org/go-concurrency-patterns-timing-out-and>Go Concurrency Patterns: Timing out, moving on</a></p><p><a href=https://blog.golang.org/advanced-go-concurrency-patterns>Advanced Go Concurrency Patterns</a></p></blockquote><p>在多线程模型中，上面几个问题给程序员带来了更多复杂性和更重的心智负担。我相信大部分 Java 程序员都无法准确的把上面几个问题都解决掉，这不是嘲讽，而是线程模型本身给使用者带来的诸多问题，这对使用者的要求实在是太高了。</p><p>那么，有没有一种编程范式，既可以解决这些问题，又具有相对比较低的认知门槛，同时也不需要像 Golang Context 那样侵入应用程序的接口？结构化并发(Structured Concurrency) 就是这样一种并发编程范式。</p><h2 id=structured-concurrency>Structured Concurrency</h2><p>2016年，ZerMQ 的作者 Martin Sústrik 在他的<a href=http://250bpm.com/blog:71 title="Structured Concurrency">文章</a> 中第一次形式化的提出结构化并发这个概念。2018 年 Nathaniel J. Smith (njs) 在 Python 中实现了这一范式 - <a href=https://trio.readthedocs.io/en/stable/>trio</a>，并在 <a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/ title="note on structured concurrency">Notes on structured concurrency, or: Go statement considered harmful</a> 一文中进一步阐述了 Structured Concurrency。同时期，Roman Elizarov 也提出了<a href=https://medium.com/@elizarov/structured-concurrency-722d765aa952>相同的理念</a>，并在 Kotlin 中实现了大家熟知的<a href=https://github.com/Kotlin/kotlinx.coroutines title="kotlin coroutine">kotlinx.coroutine</a>。2019年，OpenJDK loom project 也开始引入 structured concurrency，作为其轻量级线程和协程的一部分。</p><p>废话这么多，一方面是想提供更多的历史，方便读者更深入的了解，另一方面也是想说明，结构化并发虽然还是一个比较新的概念，具体的细节也在不断演进中，但已经有成熟的工业界实现，读者可以在自己熟悉的语言中应用该范式。</p><blockquote><p>lidill(C): <a href=http://libdill.org/>http://libdill.org/</a></p><p>trio(Python): <a href=https://trio.readthedocs.io/en/stable/>https://trio.readthedocs.io/en/stable/</a></p><p>kotin.coroutine: <a href=https://github.com/Kotlin/kotlinx.coroutines>https://github.com/Kotlin/kotlinx.coroutines</a></p><p>Venice(Swift): <a href=https://github.com/Zewo/Venice>https://github.com/Zewo/Venice</a></p></blockquote><p>Structured Concurrency 核心在于通过一种 structured 的方法实现并发程序，用具有明确入口点和出口点的控制流结构来封装并发“线程”（可以是系统级线程也可以是用户级线程，也就是协程，甚至可以是进程）的执行，确保所有派生“线程”在出口之前完成。</p><p>说的可能有点抽象，举个例子。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main_func</span>() {
  <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>myfunc</span>()
  <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>anotherfunc</span>()
  &lt;<span style=color:#a6e22e>rest</span> <span style=color:#a6e22e>of</span> <span style=color:#a6e22e>program</span>&gt;<span style=color:#f92672>...</span>
}
</code></pre></div><pre><code class=language-mermaid data-lang=mermaid>stateDiagram
    [*] --&gt; m
    m --&gt; s1
    m --&gt; s2
    state join_state &lt;&lt;join&gt;&gt;
    s1 --&gt; join_state
    m --&gt; join_state
    s2 --&gt; join_state
    join_state --&gt; [*]
</code></pre><p>假设上图中的代码具有 structured concurrency 特性（这里用的是 golang 的语法来展示）。<code>main_func</code> 里，创建了两个子任务： <code>myfunc()</code>, <code>anotherfunc</code>，这里的 func 是一个控制流结构，入口就是 func 调用开始，出口是 func 调用结束，派生出来的两个子任务需要在 <code>main_func</code> 调用结束之前先完成。当 <code>main_func</code> 结束，它涉及到的资源也都会被释放掉。外部调用者无法也无需感知 main_func 里面到底是串行的还是并行的，它只需要调用 <code>main_func</code>，然后等待它结束即可。这就是所谓的 <strong>Structured</strong>。</p><blockquote><p>大家应该都知道 <code>goto</code> 语句，一般不推荐使用它（见<a href=https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf>Dijkstra: Go To Statement Considered Harmful</a>），使用 goto 的场景基本都可以用 if, else, for loop, while loop 这些控制结构组合表达，可以把这些控制结构叫做 structured statement。</p><p>Structured Concurrency 的概念和 structured statement 类似，通过控制流来保证并发语义的可控，而不是 <code>go coroutine</code> 满天飞。</p><p>关于这方面的类比，njs 在 <a href=https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/ title="note on structured concurrency">Notes on structured concurrency, or: Go statement considered harmful</a> 中做了详细的说明，推荐阅读。</p></blockquote><p>以上是 Structured Concurrency 的核心概念，看起来是不是很简单。下面就跟着我去看看，在 Rust 里你可以怎样实现 Structured Concurrency。</p><h2 id=implement-structured-concurrency-in-rust>Implement Structured Concurrency in Rust</h2><p>目前 Rust 并没有一个成熟的库支持 Structured Concurrency 的编程范式。但是 <a href=https://github.com/tokio-rs/tokio/issues/1879>tokio#1879</a> 这个 issue 中已经开始讨论了如何在 tokio 这个底层库中提供支持，以实现 structured concurrency 风格的编程。如果你比较感兴趣，欢迎去这里贡献你的力量。</p><p>本节以 Rust 社区另外一个库 - task_scope 来介绍这种编程范式。task_scope 是一个日本小哥写的一个试验性质的库。在阅读和试验它时，我认为它提供的接口在使用上很别扭，不便于实现更复杂的并发逻辑，于是基于自己的经验，我把它的对外接口抽象成 <code>Scope</code> 和 <code>CancelScope</code>。这两个概念是继承自 trio 的实现，<code>Scope</code> 对应 trio 的 <code>nursery</code>，<code>CancelScope</code> 对应 trio 的 <code>cancel_token</code>。fork 版本见 <a href=https://github.com/starcoinorg/task_scope title=task_scope>startcoinorg/task_scope</a>。</p><h3 id=scope>Scope</h3><p>为了将具有 Structured Concurrency 行为的代码与普通的异步代码区别出来，我在 task_scope 中引入了 <code>Scope</code> 这个实体。所有 structured concurrency 的异步代码都必须在 <code>Scope</code> 的作用域中完成。下面给出用 task_scope 实现之前例子的伪代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> scope <span style=color:#f92672>=</span> Scope::new();
scope.run(<span style=color:#f92672>|</span>spawner<span style=color:#f92672>|</span> async {
  spawner.spawn(myfunc());
  spawner.spawn(anotherfunc());
  <span style=color:#f92672>&lt;</span>rest of program<span style=color:#f92672>&gt;</span>...
}).await;
</code></pre></div><p>Scope 作为 Structured Concurrency 的控制结构，任何想要进行 structured concurrency 编程的代码都必须初始化出一个 Scope 对象，调用 <code>Scope.run</code> 打开了这个控制结构的入口，在控制结构里面，可以随意的 spawn 子任务。<code>myfunc</code> 和 <code>anotherfunc</code> 都是运行在这个 scope 里。没有 Scope，父任务无法开启新的子任务，这保证了 Scope 是 Structured Concurrency 的唯一入口。最重要的是，只有当所有子任务都结束时，父任务才会结束，如果父任务在子任务结束前，就已经执行完自己的代码块，那么它需要暂停自己，并等待所有子任务结束。</p><p>Golang 的 <code>go</code> 语句最主要的问题是，当你调用了一个函数，并且函数返回了，然而你不知道它是否开启了一个/些后台任务，这些后台任务在函数返回后也不会结束（无论是有意的还是无意的）。这打破了函数的抽象，破坏了它的封装性。通过 Scope 抽象的 Structured Concurrency，就没有这个问题。任何一个函数都可以通过 scope 来运行多个并发的任务，但是函数无法返回，除非所有的子任务都完成了。因此，当一个函数返回了，你知道它是真的返回了，而不会有其他遗漏的子任务。</p><h3 id=timeout-and-cancellation>Timeout and Cancellation</h3><p>还记得我们在开篇提到的几个问题吗，里面涉及到超时和取消：<em>如何保证 main task 在规定的时间内返回，无论其成功还是失败，同时 cancel 掉它产生的所有 subtask？</em>
这一节，我们来聊聊这个问题。</p><p>我在 task_scope 中为 Scope 提供了一个方法 <code>pub fn cancel_scope(&self) -> CancelScope</code>，来获取这个 scope 的 <em>cancel_token</em>。调用 <code>CancelScope.cancel/force_cancel</code> 方法可以取消正在执行的 scope，前者给予 scope 一定的机会做优雅退出，后者则没有。以下是一个更加完善的例子，加入 cancel scope 的概念。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> scope <span style=color:#f92672>=</span> Scope::new();
<span style=color:#66d9ef>let</span> cancel_token <span style=color:#f92672>=</span> scope.cancel_scope();
scope.run(<span style=color:#f92672>|</span>spawner<span style=color:#f92672>|</span> async {
  <span style=color:#66d9ef>let</span> handle1 <span style=color:#f92672>=</span> spawner.spawn(myfunc());
  <span style=color:#66d9ef>let</span> handle2 <span style=color:#f92672>=</span> spawner.spawn(anotherfunc());
  <span style=color:#f92672>&lt;</span>rest of program<span style=color:#f92672>&gt;</span>...
  <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> select(handle1, handle2, delay(<span style=color:#ae81ff>1000</span>)).await;
  <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Err(Timeout) <span style=color:#f92672>=</span> result {
    cancel_token.cancel();
  }
}).await;
</code></pre></div><p>main task 的最后，加入一个超时判断，<code>select(handle1, handle2, delay(1000)).await</code>，如果 <code>handle1</code> 和 <code>handle2</code> 都没有在 <code>delay(1000)</code> 之后完成，那么就返回 <code>Timeout</code>，然后通过 <code>cancel_token.cancel()</code>取消scope的执行，这会导致 scope 里所有 child tasks 都收到 <code>Cancel</code> 信号，这些 child task 在下一次被调度器调度执行时，会直接退出执行。（task_scope 无法打断正在被调度器执行的 future，所以只能等到 future yield 后，下次被调度时退出，也就是说，future 中 await 的地方就是 cancel 信号的 <em>checkpoint</em>）。</p><h2 id=scope-in-scope>Scope in Scope</h2><p>当并发逻辑变得复杂，我们就会遇到在 Scope 里面开启新 Scope 的情况。一般来讲， scope 会被封装在函数里，函数的外部调用者不知道函数里是否开启了 scope。假如说，外部调用者本身是在一个 scope 里调用这个函数，就会出现 scope in scope。这种情况下，Structured Concurrency 的特性依然保持不变。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> scope <span style=color:#f92672>=</span> Scope::new();
scope.run(<span style=color:#f92672>|</span>spawner<span style=color:#f92672>|</span> async {
  spawner.spawn(func_a());
  spawner.spawn(anotherfunc());
  <span style=color:#f92672>&lt;</span>rest of program<span style=color:#f92672>&gt;</span>...
}).await;

async <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>func_a</span>() {
    <span style=color:#66d9ef>let</span> scope <span style=color:#f92672>=</span> Scope::new();
    scope.run(<span style=color:#f92672>|</span>spawner<span style=color:#f92672>|</span> async {
      spawner.spawn(myfunc());
      <span style=color:#f92672>&lt;</span>rest of program<span style=color:#f92672>&gt;</span>...
  }).await
}
</code></pre></div><p><code>func_a</code> 是一个封装有 scope 的函数，当它的子任务都完成时，它才会返回。外部调用 spawn 了 <code>func_a</code> 作为子任务执行，它也会等 <code>func_a</code> 完成后再结束。</p><p>timeout 和 cancellation 又如何处理的呢？当外部调用者的 scope 被 cancel 时， cancel 信号传递到每个 child task 里，child task future 检查自己是否被外部的 scope cancel 掉。</p><ul><li>如果是 graceful cancel，它会给自己的子任务也发送 graceful cancel 信号，然后继续执行或者等待，直到所有子任务都退出；</li><li>如果是 force cancel，那它就给自己的子任务发送 force cancel ，然后直接退出。</li></ul><p>这样，cancel 信号，就会通过 scope -> subscope -> sub-subscope 一层一层的往下传递，形成一个 cancel tree，通过 root 往下派发。</p><h2 id=practice>Practice</h2><p>讲完这些基本概念，最后给读者留一个比较经典的练习题去尝试下使用 Structured Concurrency 编程。</p><p><a href=https://en.wikipedia.org/wiki/Happy_Eyeballs>Happy Eyeballs</a> 算法是 njs 在<a href="https://www.youtube.com/watch?v=oLkfnc_UMcE">演示 trio</a> 时使用的示例，他给出的 Python 实现可以在<a href=https://github.com/python-trio/trio/blob/master/trio/_highlevel_open_tcp_stream.py>这里</a>找到。这是一个非常好的示例，强烈建议读者动手去试一试如何利用自己已有的经验去实现它（很有可能你写不出来），然后再尝试用 Strucutred Concurrency 的范式去实现。</p><p>最后，给出我用 task_scope 实现的 <a href=https://github.com/starcoinorg/task_scope/blob/master/examples/happy_eyeball.rs>Rust 版本</a>。</p><hr><footer><section><h4>Share</h4><nav class="am-nav sharing-icons"><a class=am-nav-item href="https://www.facebook.com/sharer/sharer.php?u=%2fblog%2fstructured-concurrency-in-rust%2f" title="Share on Facebook"><span class=am-icon-facebook-square aria-hidden=true></span></a><a class=am-nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=%2fblog%2fstructured-concurrency-in-rust%2f" title="Share on LinkedIn"><span class=am-icon-linkedin-square aria-hidden=true></span></a><a class=am-nav-item href="https://twitter.com/intent/tweet?url=%2fblog%2fstructured-concurrency-in-rust%2f&text=Structured%20Concurrency%20in%20Rust" title="Tweet this"><span class=am-icon-twitter-square></span></a><a class=am-nav-item href="http://service.weibo.com/share/share.php?url=%2fblog%2fstructured-concurrency-in-rust%2f&title=Structured%20Concurrency%20in%20Rust" title="Share to weibo"><span class=am-icon-weibo></span></a></nav></section></footer></article></div></div></div><footer class="footer footer-light"><div class=footer-logo><img src=../../images/footer_logo_dark.png width=50% height=50% alt></div><p class=foolter-slogo>关注我们，追踪项目最新状态</p><div class=foolter-follow><ul><li><a href=https://github.com/westarlabs/><img src=../../images/github_dark.png alt></a></li></ul></div><p>Copyright © <a href=../../ target=_blank>Westar</a> 2018-2021</p></footer><script src=https://cdn.bootcss.com/mermaid/8.4.7/mermaid.min.js></script><script src=../../js/zepto.min.js></script><script src=../../js/amazeui.min.js></script><script>window.onload=function(){mermaid.init(undefined,".language-mermaid");};</script><script>$(function(){$(window).scroll(function(){var top=$(window).scrollTop();if(top>120){$("#header").css({"background":"#110651"})}else{$("#header").css({"background-color":"rgba(0,0,0,0)"})}});function winResize(){var w=$(window).width();var h=$(window).height();$("#section-one").css({"height":h,"width":w});var p=h/w
if(p>=0.58){$(".section-one-bg").css({"background-size":"auto 100%"})}else{$(".section-one-bg").css({"background-size":"100% auto"})}}
winResize();$(window).resize(function(){winResize();});var faqLenth=$(".faq-index").length;for(var i=0;i<faqLenth;i++){$(".faq-index").eq(i).html(i+1)}})</script></body></html>