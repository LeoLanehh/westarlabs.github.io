<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="以Transaction的生命周期为线索剖析Libra核心组件"><meta property="og:description" content="围绕Transaction的生命周期，分析其接收交易、打包区块、运行上链的过程，介绍Libra的Mempool、Executor以及Storage、VM等核心组件"><meta property="og:type" content="article"><meta property="og:url" content="/blog/libra_tx/"><meta property="article:published_time" content="2020-02-09T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="以Transaction的生命周期为线索剖析Libra核心组件"><meta name=twitter:description content="围绕Transaction的生命周期，分析其接收交易、打包区块、运行上链的过程，介绍Libra的Mempool、Executor以及Storage、VM等核心组件"><meta name=generator content="Hugo 0.62.0"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"以Transaction的生命周期为线索剖析Libra核心组件","url":"\/blog\/libra_tx\/","wordCount":"5363","datePublished":"2020-02-09T00:00:00+00:00","dateModified":"2020-02-09T00:00:00+00:00","author":{"@type":"Person","name":"邓启明"},"keywords":"libra, blockchain, blog","description":"围绕Transaction的生命周期，分析其接收交易、打包区块、运行上链的过程，介绍Libra的Mempool、Executor以及Storage、VM等核心组件"}</script><link rel=canonical href=../../blog/libra_tx/><title>以Transaction的生命周期为线索剖析Libra核心组件 | Westar</title><link rel=stylesheet href=../../css/amazeui.min.css><link rel=stylesheet href=../../css/style.css></head><body><header class="am-topbar am-topbar-fixed-top header-light" style=background:#fff><div class=am-container-big><h1 class=am-topbar-brand><a href=../../ alt="westar logo" class=logo-a><img src=../../images/logo_dark.png alt></a></h1><button class="am-topbar-btn am-topbar-toggle am-btn am-btn-sm am-btn-secondary am-show-sm-only" data-am-collapse="{target: '#collapse-head'}"><span class=am-sr-only>导航切换</span> <span class=am-icon-bars></span></button><div class="am-collapse am-topbar-collapse" id=collapse-head><div class=am-topbar-right><ul class="am-nav am-nav-pills am-topbar-nav"><li><a href=../../blog/>博客</a></li><li class=am-dropdown data-am-dropdown><a class=am-dropdown-toggle data-am-dropdown-toggle href=javascript:void(0);>项目</a><ul class=am-dropdown-content><li><a href=https://starcoin.org><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Starcoin Blockchain</h3><div class=section-faq-desc>新⼀代分层的智能合约和分布式⾦融⽹络</div></div></div></a></li><li><a href=../../projects/sirius/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Sirius Protocol</h3><div class=section-faq-desc>去中心化、安全、多方、及时的二层支付协议</div></div></div></a></li><li><a href=../../projects/stargate/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Stargate Protocol</h3><div class=section-faq-desc>Starcoin 的二层协议实现</div></div></div></a></li><li><a href=../../projects/thor/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Thor Protocol</h3><div class=section-faq-desc>闪电网络上的智能合约和仲裁服务</div></div></div></a></li></ul></li><li><a href=../../about/>关于我们</a></li><li><a href=../../blog/westar_careers/>加入我们</a></li></ul></div></div></div></header><div class=news-container-detail><div class=am-container><div class=blog-main><article data-am-widget=paragraph class="am-paragraph am-paragraph-default" data-am-paragraph="{ tableScrollable: true, pureview: true }"><header><h2 class="news-title about-color blog-post-title" dir=auto>以Transaction的生命周期为线索剖析Libra核心组件</h2><p class=blog-post-meta><time datetime=2020-02-09T00:00:00Z>Sun Feb 9, 2020</time>
by
邓启明
in
<i class="fa fa-folder" aria-hidden=true></i>&nbsp;<a href=../../categories/blog rel="category tag">blog</a>
<i class="fa fa-tag" aria-hidden=true></i>&nbsp;<a href=../../tags/libra rel=tag>libra</a>, <a href=../../tags/blockchain rel=tag>blockchain</a></p></header><p>Libra涉及的东西比较多，我们从三条线介绍Libra的设计与实现：</p><ol><li>通过分析Node启动并加入到Libra网络的过程，介绍<a href=http://westar.io/blog/libra_network/>Network组件的设计与实现</a>；</li><li>围绕<a href=http://westar.io/blog/libra_tx/>Transaction的生命周期</a>，分析其接收交易、打包区块、运行上链的过程，介绍Libra的Mempool、Executor以及Storage、VM等核心组件；</li><li>围绕LibraBFT，介绍<a href=http://westar.io/blog/libra_consensus/>Consensus组件</a>以及区块达成共识的过程</li></ol><p>前面我们讲述了Libra的第一条主线——Node启动以及加入网络的过程，详细介绍了Network组件的设计与实现。这里，我们将要讲述Libra的第二条主线——Transaction的生命周期，再围绕Transaction的生命周期，逐个讲述Libra各个核心组件的一些设计与实现。在讲述生命周期之前，我们先了解一下账号模型以及Transaction与Move合约的关系。</p><h3 id=heading>账号模型</h3><p>实际上区块链可以简单的理解为：使用Transaction为载体，按大部分人认可的顺序记录每个Address的变更过程。为了达到这个目的，区块链发展至今抽象出两种账号模型：以BTC为代表的UTXO模型和以ETH为代表的Account模型。这两种模型各有优劣，简单对比一下：</p><p><img src=./images/libra_account.jpg alt=libra-account></p><p>UTXO的英文是Unspent Transaction Output，直译就是未消费的交易输出，一个Address的当前状态就是一个UTXO列表。UTXO模型下，消费(构造Transaction)的时候拿出一个或者多个UTXO当作当前Transaction的Input，然后生成多个UTXO，Input和Output的总额是相等的。在未来的某个时刻，这些Output又被当做其他Transaction的Input。是不是跟纸钞有些像？而Account模型中，每个Address通常包含一个的总额和SequenceNumber计数器。每次消费(构造Transaction)的时候会从当前Address的总额中减去消费额，在另一个Address中加上相应的消费额，同时通过SequenceNumber递增的方式，保证当前Address构造的出来的所有Transaction有先后顺序，从而保障账号的状态正确。</p><p>Libra使用的Account模型来表达账本数据，所以Transaction有严格的先后顺序。这点在后面我们还会提到。</p><h3 id=transactionmove>Transaction与Move合约</h3><p>前面我们了解了账号模型，为了便于理解，以支付的场景做了类比。给我们的感觉就是，Transaction的作用就是对一个数字进行加减运算，例如Alice给Bob转了一笔账。那就不能应用于更多、更复杂的场景吗？比如游戏。区块链起步的时候，表达能力相对比较简单，随着区块链的推广，大家的需求越来越丰富，最初的设计难以满足。我们希望能通过一门语言，在链上表达我们的需求，所以虚拟机、智能合约以及合约语言顺势产生了。这是一个很广阔的话题。Libra推出了Move语言作为合约语言，这里我们不展开讲。那么Transaction、链、Move到底是什么关系呢？</p><p><img src=./images/libra-tx-1.png alt=libra-tx-1></p><p>我们假设上图是某个时刻，链上所存储的账号数据，其中Alice有一个Move定义的合约，code被存储在她的账号下。上图的第①步中，Bob构建一个Transaction，在Transaction中指定运行Alice账号下对应的合约的一个方法，并从自己的账号下取出该合约方法能理解的数据作为方法的参数，然后对Transaction进行签名并广播出去。图中第②步，矿工收到Bob的Transaction，打包到Block中，然后执行Bob的Transaction，并且将结果写到Bob的账号下面。整个过程中，大概的理解就是，Move定义了一段逻辑，Transaction设置了运行逻辑用到的数据，链记录了逻辑运行之后的最终状态。</p><h3 id=transaction>Transaction的生命周期</h3><p>前面我们讲了两个背景知识，接下来，我们对Transaction的生命周期做一个整体的认识：</p><p><img src=./images/libra-tx-2.jpg alt=libra-tx-2></p><p>这张图也是Libra的技术白皮书中的一张图，跟前面介绍Libra核心组件那张图有些像，但是箭头上多了一些数字。这张图实际上是表示一个Transaction从生成到打包，从执行到上链的完整的生命周期。下面我们依次介绍一下每个数字大概代表的意思:</p><pre><code>1. 交易被用户使用wallet或者cli提交到AdmissionControl
2. AdmissionControl运行VM做一些Transaction的前置校验，例如交易的签名校验等等，过滤掉一些无效交易
3. Transaction前置校验通过后，会被提交到Mempool中
4. Transaction被设置为Ready状态，等待被打包进Block中
5. Transaction被设置为Ready状态之后，会被广播给其他Mempool
6. Validator节点的Consensus组件pull对应的Mempool组件，获取一批Ready状态的Transaction，用于创建Block
7. 新创建的Block被广播给其他Validator节点，并且选举Block
8. 拿到新的Block之后，提交到Executor组件执行Block
9. 新Block中的所有交易被提交给VirtualMachine组件，VM按顺序执行Block的所有交易
10. 提交被共识选举胜出的Block
11. 广播被共识选举胜出的Block
12. 存储胜出的Block中所有被KEEP的Transaction以及每个address对应的最终状态
</code></pre><p>我们对Transaction的生命周期有了一个直观的认识，接下来，我们深入每一个组件内部，了解更多的设计和实现细节。</p><h3 id=ac>AC服务</h3><p>从交易被用户提交开始，首先到AC服务。</p><p>在讲述第一条主线的时候，我们提到了AC是一个GRPC服务，相当于是Node的一个网关。Node包含多个GRPC服务和很多的RPC接口，然而只有跟用户打交道的两类接口，才有必要暴露出去给wallet或者cli调用：</p><ol><li>提交Transaction的接口</li><li>用户状态相关的接口</li></ol><p>所以AC没有太多的逻辑，只是对Node内部部分GRPC接口的一个封装，以暴露给用户使用。另外AC还有一个作用是对提交过来的Transaction做简单的过滤。</p><h3 id=mempool>Mempool服务</h3><p>交易通过AC被提交到了Mempool服务。</p><p>在讲述第一条主线的时候，我们知道Mempool是用来存储未上链的Transaction。我们先来看一看Mempool的整体设计：</p><p><img src=./images/libra-tx-3.png alt=libra-tx-3></p><p>Mempool主要包含两个模块：</p><ol><li>Mempool Service：是一个Grpc服务，用来接收从AC提交过来的Transaction</li><li>Share Mempool：主要有两个作用，一个是通过Mempool协议(在第一条主线的时候有提到)在不同的Mempool节点之间同步Transaction，另外是存储和处理Transaction</li></ol><p>我们对Mempool有了一个整体的认识，但是还有些疑问，Mempool究竟对Transaction做了什么处理呢？什么情况下Transaction会被打包？Transaction又是什么时候被广播给其他Mempool？接下来我们就解答一下这些疑问。</p><h5 id=mempooltransaction>Mempool内的Transaction状态转化</h5><p>Transaction提交到Mempool之后，首先会根据来源将其标记为不同的状态：</p><ol><li>Unready：用户主动提交到Mempool Service的交易状态</li><li>NonQualified：其他节点同步过来的交易状态</li></ol><p>这些Transaction会按一定的顺序排序，等待被标记成Ready状态。前面我们提到了Libra采用Account模型，通过SequenceNumber将用户发起的Transaction按顺序关联起来，当Mempool发现某个Transaction前面的所有其他Transaction都被上链了或者都是Ready状态了，那么这个Transaction就可以被标记为Ready状态了，也就意味着这个Transaction具备打包进区块的条件了。如果当前被设置成Ready状态的Transaction是从Unready状态转变过来的(也就是用户通过AC提交到当前Mempool)，那么该Transaction会被转发给其他的Mempool。</p><p><img src=./images/libra-tx-4.png alt=libra-tx-4></p><p>上图是Transaction在Mempool中大致的状态转化过程，而Transaction大概的排序规则是：gas_price>expiration_time>address>sequence_number</p><h3 id=consensus>Consensus组件</h3><p>前面介绍了Mempool的状态转化，用户提交的Transaction处于Ready状态，等待被打包到区块中。考虑到Consensus的复杂性，以及当前主线主要是介绍Transaction的生命周期，这里只简单的介绍一下上链流程（多节点达成共识的过程将在第3条主线中详细介绍），大概如下：</p><p><img src=./images/libra-tx-5.png alt=libra-tx-5></p><p>其中compute->execute以及commit->store会在后面讲，vote将在第3条主线详细讲，这里暂时只需要注意两个地方：</p><ol><li>Consensus组件主动去Mempool中pull一批Ready状态的Transaction，并打包到Block</li><li>Block被选举并提交之后，Consensus组件会主动去删除Mempool中被提交的Transaction</li></ol><h3 id=executorvm>Executor&VM组件</h3><p>由于Executor只是运行VM的一个入口，这里把Executor和VM合并到一起介绍。前面Consensus组件的流程中，Block被Build之后会被提交到Executor中comput，再进入VM中execute，这就是执行Transaction。也就是compute->execute过程，有些细节需要注意：</p><p><img src=./images/libra-tx-6.jpg alt=libra-tx-6></p><p>其中浅颜色由Executor发起，深颜色是在VM中执行的Move合约。Consensus组件将新的Block提交到Executor组件之后，Executor会为Block提供运行环境，初始化VM，依次在VM中运行Block的Coinbase和其他用户Transaction。所以VM会最先执行Coinbase交易，也就运行LibraAccount合约中的block prologue。然后再按顺序依次执行Block中打包的Transaction，最后将执行之后的状态返回给Consensus组件。</p><h3 id=storage>Storage服务</h3><p>在介绍Consensus组件的时候，我们提到了Block会被commit，数据最终会被写入Storage服务。也就是commit->store流程，这时候用户提交的Transaction已经被大家认可。关于Storage服务，我们可能会有两个疑问：</p><ol><li>Storage服务包含哪些模块？</li><li>Storage最终存储了哪些数据？</li></ol><h5 id=storage-1>Storage模块</h5><p>Storage是一个GRPC服务，存储了所有链上的数据，用户的账本状态等信息就是从Storage获取的。Libra选择了RocksDB作为底层存储的数据库，SchemaDB基于RocksDB封装了对数据统一的CRUD操作以及Key-Value的系列化与反序列化方式。LibraDB是围绕Libra的账本数据和特点，定义了一系列数据结构，并针对这些数据结构进行数据库的操作。将所有的这些操作，封装成Storage服务，提供给Executor、AC等组件使用。</p><p><img src=./images/libra-tx-7.png alt=libra-tx-7></p><h5 id=heading-1>账本数据</h5><p>前面讲述Storage服务包含的模块，我们了解到LibraDB围绕Libra账本的特点定义了一些数据结构，Libra账本有什么特点？那么包含哪些核心数据结构呢？</p><ol><li><p>账本特点</p><p>Libra采用Account，需要存储全局的用户状态，当前状态的所有历史交易以及交易的顺序。也就是说，Storage需要存储的主要数据：用户状态、交易及交易顺序。跟其他公链不同的是，一般的公链通过记录Block顺序(Block内的交易也是有序的)，来达到记录所有交易和交易的顺序的目的。而Libra直接存储交易，采用Merkle Accumulator来记录交易的顺序。</p></li></ol><p><img src=./images/libra-tx-8.png alt=libra-tx-8></p><ol><li><p>核心数据结构</p><p>Libra为了存储用户状态、交易及交易顺序，分别使用了Sparse Merkle Tree和Merkle Accumulator。</p></li></ol><p><img src=./images/libra-tx-9.png alt=libra-tx-9></p><p>​ SparseMerkleTree使用256比特存储用户状态，理论上总共可以有2的256次方个账号。上图是4比特SparseMerkleTree的例子，每个橙色的叶子节点代表了一个用户；正方形的方块是占位符，表明该分支下没有账号，减少账号的存储；</p><p><img src=./images/libra-tx-10.png alt=libra-tx-10></p><p>​ MerkleAccumulator存储交易以及交易的顺序。上图中，每个深颜色的叶子节点表示一个Transaction；正方形的方块是占位符。新上链的交易会按顺序一个一个被加入到后面。</p><p>​ 上面提到了Storage的两个核心数据结构，整个Storage都在围绕他们进行存储和优化，更多细节不再展开。</p><h3 id=heading-2>总结</h3><p>​ 以上是Transaction整个生命周期的过程，依次经过AC、Mempool、Consensus、Executor、VM的处理，最终存储到Storage。然后我们深入到每一个组件或者服务，既介绍了他们的一些设计和实现，也了解了Transaction被处理的核心细节。</p><hr><footer><section><h4>Share</h4><nav class="am-nav sharing-icons"><a class=am-nav-item href="https://www.facebook.com/sharer/sharer.php?u=%2fblog%2flibra_tx%2f" title="Share on Facebook"><span class=am-icon-facebook-square aria-hidden=true></span></a><a class=am-nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=%2fblog%2flibra_tx%2f" title="Share on LinkedIn"><span class=am-icon-linkedin-square aria-hidden=true></span></a><a class=am-nav-item href="https://twitter.com/intent/tweet?url=%2fblog%2flibra_tx%2f&text=%e4%bb%a5Transaction%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%ba%e7%ba%bf%e7%b4%a2%e5%89%96%e6%9e%90Libra%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6" title="Tweet this"><span class=am-icon-twitter-square></span></a><a class=am-nav-item href="http://service.weibo.com/share/share.php?url=%2fblog%2flibra_tx%2f&title=%e4%bb%a5Transaction%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%ba%e7%ba%bf%e7%b4%a2%e5%89%96%e6%9e%90Libra%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6" title="Share to weibo"><span class=am-icon-weibo></span></a></nav></section></footer></article></div></div></div><footer class="footer footer-light"><div class=footer-logo><img src=../../images/footer_logo_dark.png width=50% height=50% alt></div><p class=foolter-slogo>关注我们，追踪项目最新状态</p><div class=foolter-follow><ul><li><a href=https://github.com/westarlabs/><img src=../../images/github_dark.png alt></a></li></ul></div><p>Copyright © <a href=../../ target=_blank>Westar</a> 2018-2021</p></footer><script src=https://cdn.bootcss.com/mermaid/8.4.7/mermaid.min.js></script><script src=../../js/zepto.min.js></script><script src=../../js/amazeui.min.js></script><script>window.onload=function(){mermaid.init(undefined,".language-mermaid");};</script><script>$(function(){$(window).scroll(function(){var top=$(window).scrollTop();if(top>120){$("#header").css({"background":"#110651"})}else{$("#header").css({"background-color":"rgba(0,0,0,0)"})}});function winResize(){var w=$(window).width();var h=$(window).height();$("#section-one").css({"height":h,"width":w});var p=h/w
if(p>=0.58){$(".section-one-bg").css({"background-size":"auto 100%"})}else{$(".section-one-bg").css({"background-size":"100% auto"})}}
winResize();$(window).resize(function(){winResize();});var faqLenth=$(".faq-index").length;for(var i=0;i<faqLenth;i++){$(".faq-index").eq(i).html(i+1)}})</script></body></html>