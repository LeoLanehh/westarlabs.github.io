<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta property="og:title" content="剖析Libra的Network组件"><meta property="og:description" content="通过分析Node启动并加入到Libra网络的过程，介绍Network组件的设计与实现"><meta property="og:type" content="article"><meta property="og:url" content="/blog/libra_network/"><meta property="article:published_time" content="2020-02-08T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="剖析Libra的Network组件"><meta name=twitter:description content="通过分析Node启动并加入到Libra网络的过程，介绍Network组件的设计与实现"><meta name=generator content="Hugo 0.62.0"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"剖析Libra的Network组件","url":"\/blog\/libra_network\/","wordCount":"3238","datePublished":"2020-02-08T00:00:00+00:00","dateModified":"2020-02-08T00:00:00+00:00","author":{"@type":"Person","name":"邓启明"},"keywords":"libra, blockchain, blog","description":"通过分析Node启动并加入到Libra网络的过程，介绍Network组件的设计与实现"}</script><link rel=canonical href=../../blog/libra_network/><title>剖析Libra的Network组件 | Westar</title><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-WQSZ69DVJZ"></script><script>    window.dataLayer = window.dataLayer || [];    function gtag(){dataLayer.push(arguments);}    gtag('js', new Date());    gtag('config', 'G-WQSZ69DVJZ');</script><link rel=stylesheet href=../../css/amazeui.min.css><link rel=stylesheet href=../../css/style.css></head><body><header class="am-topbar am-topbar-fixed-top header-light" style=background:#fff><div class=am-container-big><h1 class=am-topbar-brand><a href=../../ alt="westar logo" class=logo-a><img src=../../images/logo_dark.png alt></a></h1><button class="am-topbar-btn am-topbar-toggle am-btn am-btn-sm am-btn-secondary am-show-sm-only" data-am-collapse="{target: '#collapse-head'}"><span class=am-sr-only>导航切换</span> <span class=am-icon-bars></span></button><div class="am-collapse am-topbar-collapse" id=collapse-head><div class=am-topbar-right><ul class="am-nav am-nav-pills am-topbar-nav"><li><a href=../../blog/>博客</a></li><li class=am-dropdown data-am-dropdown><a class=am-dropdown-toggle data-am-dropdown-toggle href=javascript:void(0);>项目</a><ul class=am-dropdown-content><li><a href=https://starcoin.org><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Starcoin Blockchain</h3><div class=section-faq-desc>新⼀代分层的智能合约和分布式⾦融⽹络</div></div></div></a></li><li><a href=../../projects/sirius/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Sirius Protocol</h3><div class=section-faq-desc>去中心化、安全、多方、及时的二层支付协议</div></div></div></a></li><li><a href=../../projects/stargate/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Stargate Protocol</h3><div class=section-faq-desc>Starcoin 的二层协议实现</div></div></div></a></li><li><a href=../../projects/thor/><div class=nav-dropdown-item><div class=left><div class="icon nav-icon-sirius"></div></div><div class=right><h3 class=am-gallery-title>Thor Protocol</h3><div class=section-faq-desc>闪电网络上的智能合约和仲裁服务</div></div></div></a></li></ul></li><li><a href=../../about/>关于我们</a></li><li><a href=../../blog/westar_careers/>加入我们</a></li></ul></div></div></div></header><div class=news-container-detail><div class=am-container><div class=blog-main><article data-am-widget=paragraph class="am-paragraph am-paragraph-default" data-am-paragraph="{ tableScrollable: true, pureview: true }"><header><h2 class="news-title about-color blog-post-title" dir=auto>剖析Libra的Network组件</h2><p class=blog-post-meta><time datetime=2020-02-08T00:00:00Z>Sat Feb 8, 2020</time>
by
邓启明
in
<i class="fa fa-folder" aria-hidden=true></i>&nbsp;<a href=../../categories/blog rel="category tag">blog</a>
<i class="fa fa-tag" aria-hidden=true></i>&nbsp;<a href=../../tags/libra rel=tag>libra</a>, <a href=../../tags/blockchain rel=tag>blockchain</a></p></header><p>6 月 18 日，Facebook 发布了 Libra 白皮书及源码，引起了业界的广泛关注与讨论。</p><p>这里我们通过分析Libra的源码，探索Libra的各个组件，来了解一下Libra的整体设计与实现。</p><h3 id=libra>Libra核心组件</h3><p>在进入主题之前，我们先对Libra有一个整体的认识：</p><p><img src=./images/libra.jpg alt=libra-1></p><p>看过Libra技术白皮书的朋友，应该都记得这张图，下面简单介绍一下这些核心的组件（后面还会有更详细的讨论）：</p><p>​ a. AdmissionControl服务：简称AC，翻译过来叫准入控制，可以理解为Libra的网关，将跟用户打交道的接口暴露给用户，例如提交Transaction、获取用户状态等等</p><p>​ b. Mempool服务：存储未上链交易</p><p>​ c. Consensus组件：LibraBFT共识组件</p><p>​ d. VirtualMachine组件：简称VM，运行Move合约的虚拟机</p><p>​ e. Execution组件：VM的入口，已换成Executor组件</p><p>​ f. Storage服务：存储所有链上数据</p><p>​ g. Network组件：上图中隐含了一个Network组件，不论是Node启动还是跟其他节点通信，都需要Network组件。在第一条主线中，我们重点介绍Network组件。</p><p>注意，上面介绍各个核心组件的时候，我们区分了组件和服务，两者的区别是：组件没有额外监听端口，与node共用同一个端口，而服务会单独监听一个端口，通常是GRPC服务。</p><h3 id=libra-1>Libra设计与实现</h3><p>Libra涉及的东西比较多，我们从三条线介绍Libra的设计与实现：</p><ol><li>通过分析Node启动并加入到Libra网络的过程，介绍<a href=http://westar.io/blog/libra_network/>Network组件的设计与实现</a>；</li><li>围绕<a href=http://westar.io/blog/libra_tx/>Transaction的生命周期</a>，分析其接收交易、打包区块、运行上链的过程，介绍Libra的Mempool、Executor以及Storage、VM等核心组件；</li><li>围绕LibraBFT，介绍<a href=http://westar.io/blog/libra_consensus/>Consensus组件</a>以及区块达成共识的过程</li></ol><p>如果想了解或者使用Libra，我们需要先启动一个节点，并将它加入到网络中。接下来，我们看看第一条主线，了解一下Node的启动以及Network的设计与实现。</p><h3 id=node>Node启动流程</h3><p>我们先看一下Node大概的启动流程，主要包含两部分：</p><ol><li><p>生成config</p><p>Libra的Config的模块中，能构建3种类型的配置文件，分别是validator、faucet、fullnode的配置文件。其中faucet配置是水龙头服务相关的一些配置，通常只有测试网络中第一个validator节点才需要。</p><p><img src=./images/libra-start-1.png alt=conf-build></p></li><li><p>启动node</p></li></ol><p><img src=./images/libra-start-2.png alt=node-start></p><p>上图中Libra-node用于启动单节点，Libra-swarm用于批量启动多节点。接下来，我们分别看一下这两步的一些实现细节，以及之前的准备工作。</p><h3 id=heading>准备工作</h3><p>在一切继续之前，我们先准备需要依赖的环境</p><p>​ 1). 获取Libra代码</p><p>​ git clone <a href=https://github.com/libra/libra.git>https://github.com/libra/libra.git</a></p><p>​ 2). 编译和运行环境</p><p>​ a. 建议使用Libra自带的脚本script/dev_setup.sh安装环境依赖</p><p>​ b. 或者自己手动安装rust、cargo、git、pb、go、CMake等工具</p><p>​</p><h3 id=config>生成config</h3><p>​ 从前面的Node启动流程我们了解到，启动node首先需要生成配置。Libra包含的配置文件比较多，我们来整体看一下配置文件：</p><p><img src=./images/libra-start-3.png alt=config></p><p>​ 不过没有特殊需求的话，需要我们特别注意和关注的配置其实也不算多（见上图蓝色部分），主要有：</p><p>​ a. Node的角色分为Validator和FullNode</p><p>​ b. 生成3个秘钥，2个ed25519算法生成，分别用于打包block签名、网络的消息签名，Libra提供了一个generate_keypair工具生成ed25519秘钥(cargo run -p generate_keypair &ndash; -o mint.key)，1个是x25519算法生成，用于标识节点身份</p><p>​ c. 数据存储路径，默认会生成临时路径</p><p>​ d. network_peers：存放网络中Node的公钥等信息，主要包含网络消息签名的公钥和节点身份的公钥</p><p>​ e. seed_peers：当前节点加入网络主动去连接的node的信息</p><p>​ f. consensus_peers：所有Validator节点的信息，Libra网络是一个许可形网络</p><p>​ g. 各服务的端口以及其他配置，没有特殊要求的话，默认就好</p><h3 id=node-1>启动Node</h3><ol><li><p>连接Libra的测试网络</p><p>sh scripts/cli/start_cli_testnet.sh</p></li><li><p>自建节点</p><p>cargo run -p libra-node</p><p>或者</p><p>cargo run -p libra-swarm &ndash; -s</p></li></ol><p>当前node启动起来之后，会根据seed_peers的配置，去连接相应的node节点，加入到网络中去，如果没有seed_peers则会启动一个单独的网络。接下来，我们深入了解一下Node的Network的一些设计与核心实现。</p><h3 id=network>Network组件</h3><h5 id=1-network>1. Network核心模块</h5><p>我们整体看一下Network包含哪些模块：</p><p><img src=./images/libar-network-1.jpg alt=network-mod></p><p>上面中，从下往上看：</p><p>​ a. MemSocket实现了UNIX domain socket的功能，一般用于测试</p><p>​ b. TcpSocket网络连接</p><p>​ c. Transport可以理解为MemSocket和TcpSocket的一层抽象，封装了socket的操作</p><p>​ d. Noise是一种加密协议，前面提到的用于网络消息签名的ed25519私钥，就是作用在这里</p><p>​ e. Rpc是Libra自己实现的远程过程调用协议，调用方会等待被调用方返回结果</p><p>​ f. DirectSend从字面理解是直接发送，调用方发送完立即返回，不等待被调用方返回结果</p><p>​ g. Negotiate可以理解为对Rpc和DirectSend的抽象</p><p>​ h. MultiStream用于多路复用，使用了yamux协议。通俗的理解就是在同一个Tcp连接上，从逻辑上将每种上层协议封装成一个单独SubStream，以实现多个上层协议共用一个Tcp连接的情况。这一点后面我们还会提到。</p><p>以上是Libra的Network组件的一个整体实现，接下来我们介绍一下Libra的协议。</p><h5 id=2-libra>2. Libra的主要协议</h5><p>上面我们对Network组件有了一个宏观的认识，这里我们介绍一下Libra包含的协议：</p><p><img src=./images/libra-network-2.jpg alt=network-protocol></p><p>上图中，从下往上看：</p><p>​ a. PeerManager封装了网络连接以及多路复用的操作</p><p>​ b. Identity协议：前面提到的x25519私钥，就是Identity协议用于标识当前节点的身份，协议会根据节点的Role将Validator网络与Fullnode网络进行隔离</p><p>​ c. Health协议：定期随机选择一个节点发送探活消息</p><p>​ d. Discovery协议：每个round从相邻的节点同步节点信息，以发现新节点，可以理解为gossip协议</p><p>​ e. AdmissionControl协议：只有RPC的实现，Fullnode节点在收到用户提交的Transaction之后，通过AC协议将Transaction转发给Validator节点</p><p>​ f. Mempool协议：只有DirectSend实现，用于不同的Mempool之间同步Transaction</p><p>​ g. Consensus协议：包含RPC和DirectSend，用于Validator之间达成共识</p><p>​ h. StateSynchronizer协议：只有DirectSend实现，不同node之间寻找Block</p><p>前面我们提到了多路复用，上面的协议都是通过MultiStream分别开了SubStream，逻辑上把消息协议区分出来。其中Identity、Health、Discovery是所有node都会包含的基本协议，而Consensus是只有Validator节点才会包含的协议。</p><h3 id=heading-1>总结</h3><p>最开始我们讲了Node启动流程，讲述了config配置需要注意的地方以及node启动的方式和流程。然后我们深入到Network组件，讲了Network的组成模块以及提供的协议能力。我们以单节点为例，将整个启动以及加入网络的过程总结如下图：</p><p><img src=./images/libra-start-4.png alt=network></p><p>其中黄色部分表示在Network的端口是开启了SubStream，添加了相应的协议和协议处理过程；绿色部分部分表示服务或者组件实例化，可以看出Storage和Executor不依赖Network；初始化Discovery协议的时候，节点会去连接seed节点，并且seed节点会验证Identity。以上是节点启动以及加入到网络的大概流程。</p><h3 id=heading-2>相关链接</h3><p><a href=https://github.com/libra/libra>https://github.com/libra/libra</a></p><p><a href=https://developers.libra.org/docs/the-libra-blockchain-paper>https://developers.libra.org/docs/the-libra-blockchain-paper</a></p><hr><footer><section><h4>Share</h4><nav class="am-nav sharing-icons"><a class=am-nav-item href="https://www.facebook.com/sharer/sharer.php?u=%2fblog%2flibra_network%2f" title="Share on Facebook"><span class=am-icon-facebook-square aria-hidden=true></span></a><a class=am-nav-item href="https://www.linkedin.com/shareArticle?mini=true&url=%2fblog%2flibra_network%2f" title="Share on LinkedIn"><span class=am-icon-linkedin-square aria-hidden=true></span></a><a class=am-nav-item href="https://twitter.com/intent/tweet?url=%2fblog%2flibra_network%2f&text=%e5%89%96%e6%9e%90Libra%e7%9a%84Network%e7%bb%84%e4%bb%b6" title="Tweet this"><span class=am-icon-twitter-square></span></a><a class=am-nav-item href="http://service.weibo.com/share/share.php?url=%2fblog%2flibra_network%2f&title=%e5%89%96%e6%9e%90Libra%e7%9a%84Network%e7%bb%84%e4%bb%b6" title="Share to weibo"><span class=am-icon-weibo></span></a></nav></section></footer></article></div></div></div><footer class="footer footer-light"><div class=footer-logo><img src=../../images/footer_logo_dark.png width=50% height=50% alt></div><p class=foolter-slogo>关注我们，追踪项目最新状态</p><div class=foolter-follow><ul><li><a href=https://github.com/westarlabs/><img src=../../images/github_dark.png alt></a></li></ul></div><p>Copyright © <a href=../../ target=_blank>Westar</a> 2018-2021</p></footer><script src=https://cdn.bootcss.com/mermaid/8.4.7/mermaid.min.js></script><script src=../../js/zepto.min.js></script><script src=../../js/amazeui.min.js></script><script>window.onload=function(){mermaid.init(undefined,".language-mermaid");};</script><script>$(function(){$(window).scroll(function(){var top=$(window).scrollTop();if(top>120){$("#header").css({"background":"#110651"})}else{$("#header").css({"background-color":"rgba(0,0,0,0)"})}});function winResize(){var w=$(window).width();var h=$(window).height();$("#section-one").css({"height":h,"width":w});var p=h/w
if(p>=0.58){$(".section-one-bg").css({"background-size":"auto 100%"})}else{$(".section-one-bg").css({"background-size":"100% auto"})}}
winResize();$(window).resize(function(){winResize();});var faqLenth=$(".faq-index").length;for(var i=0;i<faqLenth;i++){$(".faq-index").eq(i).html(i+1)}})</script></body></html>